import { Component, EventEmitter, OnDestroy, OnInit, Output } from '@angular/core';
import { Account, Asset, AssetType, Category, Grouped } from '@walletstate/angular-client';
import { FlatTreeControl } from '@angular/cdk/tree';
import { MatTreeFlatDataSource, MatTreeFlattener } from '@angular/material/tree';
import { Subscription } from 'rxjs';
import { AccountsService } from '../../shared/accounts.service';
import { CategoriesService } from '../../shared/categories.service';
import { AssetsService } from '../../shared/assets.service';
import { SelectionModel } from '@angular/cdk/collections';
import { AppAnalyticsFilter, BasicFilterData } from './analytics-filter.model';

interface FilterFlatNode {
  expandable: boolean;
  name: string;
  filterKey?: string;
  id: string;
  parentId?: string;
  level: number;
}

interface FilterNode {
  name: string;
  filterKey?: string;
  id: string;
  parentId?: string;
  children?: FilterNode[];
}

@Component({
  selector: 'app-analytics-filter',
  templateUrl: './analytics-filter.component.html',
  styleUrl: './analytics-filter.component.scss',
})
export class AnalyticsFilterComponent implements OnInit, OnDestroy {
  @Output() applyFilter: EventEmitter<AppAnalyticsFilter> = new EventEmitter<AppAnalyticsFilter>();

  categoriesSubscription: Subscription;
  accountsSubscription: Subscription;
  assetsSubscription: Subscription;

  private _transformer = (node: FilterNode, level: number) => {
    return {
      expandable: !!node.children && node.children.length > 0,
      name: node.name,
      filterKey: node.filterKey,
      id: node.id,
      parentId: node.parentId,
      level: level,
    };
  };

  treeControl = new FlatTreeControl<FilterFlatNode>(
    node => node.level,
    node => node.expandable
  );

  treeFlattener = new MatTreeFlattener(
    this._transformer,
    node => node.level,
    node => node.expandable,
    node => node.children
  );

  dataSource = new MatTreeFlatDataSource(this.treeControl, this.treeFlattener);

  checklistSelection = new SelectionModel<FilterFlatNode>(true);

  constructor(
    private accountsService: AccountsService,
    private categoriesService: CategoriesService,
    private assetsService: AssetsService
  ) {}

  ngOnInit(): void {
    this.dataSource.data = [
      { name: 'Categories', children: [], id: 'categories-filter-id' },
      { name: 'Accounts', children: [], id: 'accounts-filter-id' },
      { name: 'Assets', children: [], id: 'assets-filter-id' },
      { name: 'Generated by', children: [], id: 'generated-by-filter-id' },
      { name: 'Spent on', children: [], id: 'spent-on-filter-id' },
    ];
    this.categoriesSubscription = this.categoriesService.groups.subscribe(categoriesGroups => {
      this.dataSource.data[0].children = this.categoriesGroupsToNode(categoriesGroups, this.dataSource.data[0].id);
      this.dataSource.data = [...this.dataSource.data];
    });
    this.accountsSubscription = this.accountsService.groups.subscribe(accountsGroups => {
      this.dataSource.data[1].children = this.accountsGroupsToNode(accountsGroups, this.dataSource.data[1].id);
      this.dataSource.data = [...this.dataSource.data];
    });
    this.assetsSubscription = this.assetsService.assets.subscribe(assets => {
      this.dataSource.data[2].children = this.assetsToNode(assets, 'assets', this.dataSource.data[2].id);
      this.dataSource.data[3].children = this.assetsToNode(assets, 'generatedBy', this.dataSource.data[3].id);
      this.dataSource.data[4].children = this.assetsToNode(assets, 'spentOn', this.dataSource.data[4].id);
      this.dataSource.data = [...this.dataSource.data];
    });
  }

  ngOnDestroy(): void {
    this.categoriesSubscription && this.categoriesSubscription.unsubscribe();
    this.accountsSubscription && this.accountsSubscription.unsubscribe();
    this.assetsSubscription && this.assetsSubscription.unsubscribe();
  }

  hasChild = (_: number, node: FilterFlatNode) => node.expandable;

  isSelected = (node: FilterFlatNode) => this.checklistSelection.isSelected(node);
  isNotSelected = (node: FilterFlatNode) => !this.isSelected(node);

  /** Whether all the descendants of the node are selected */
  descendantsAllSelected(node: FilterFlatNode): boolean {
    const descendants = this.treeControl.getDescendants(node);
    return descendants.every(this.isSelected);
  }

  /** Whether part of the descendants are selected */
  descendantsPartiallySelected(node: FilterFlatNode): boolean {
    const descendants = this.treeControl.getDescendants(node);
    return descendants.some(this.isSelected) && !this.descendantsAllSelected(node);
  }

  /** Toggle the item selection. Select/deselect all the descendants node */
  nodeSelectionToggle(node: FilterFlatNode): void {
    const descendants = this.treeControl.getDescendants(node);
    this.checklistSelection.toggle(node);
    this.isSelected(node)
      ? this.checklistSelection.select(...descendants)
      : this.checklistSelection.deselect(...descendants);

    this.adjustParentNodeSelection(node);
  }

  leafSelectionToggle(node: FilterFlatNode): void {
    this.checklistSelection.toggle(node);
    this.adjustParentNodeSelection(node);
  }

  /** Fix synchronization between SelectionModel and checkbox*/
  private adjustParentNodeSelection(node: FilterFlatNode) {
    if (node.level < 1) {
      return null;
    }

    const parentLevel = node.level - 1;
    const parent = this.treeControl.dataNodes.find(n => n.level === parentLevel && n.id === node.parentId);

    if (!parent) {
      return null;
    }

    const descendants = this.treeControl.getDescendants(parent);
    if (descendants.every(this.isSelected)) {
      this.checklistSelection.select(parent);
      this.adjustParentNodeSelection(parent);
    }

    if (descendants.some(this.isNotSelected)) {
      this.checklistSelection.deselect(parent);
      this.adjustParentNodeSelection(parent);
    }
  }

  onApply() {
    const filter = this.selectedNodesToFilter(this.checklistSelection.selected);
    this.applyFilter.next(filter);
  }

  private selectedNodesToFilter(nodes: FilterFlatNode[]): AppAnalyticsFilter {
    const filterData: BasicFilterData = {
      categories: [],
      accounts: [],
      assets: [],
      spentOn: [],
      generatedBy: [],
    };

    nodes.filter(node => node.filterKey).forEach(node => filterData[node.filterKey].push(node.id));

    return AppAnalyticsFilter.base(filterData);
  }

  private accountsGroupsToNode(accountsGroups: Grouped<Account>[], parentId: string): FilterNode[] {
    return accountsGroups.map(group => {
      return {
        name: group.name,
        id: group.id,
        parentId: parentId,
        children: (group.items ?? []).map(account => {
          return { name: account.name, filterKey: 'accounts', id: account.id, parentId: group.id };
        }),
      };
    });
  }

  private categoriesGroupsToNode(categoriesGroups: Grouped<Category>[], parentId: string): FilterNode[] {
    return categoriesGroups.map(group => {
      return {
        name: group.name,
        id: group.id,
        parentId: parentId,
        children: (group.items ?? []).map(category => {
          return { name: category.name, filterKey: 'categories', id: category.id, parentId: group.id };
        }),
      };
    });
  }

  private assetsToNode(assets: Asset[], filterKey: string, parentId: string): FilterNode[] {
    const nodes: FilterNode[] = Object.values(AssetType).map(type => {
      return { name: type, children: [], id: `asset-type-id-${parentId}-${type}`, parentId: parentId };
    });
    assets.forEach(asset => {
      const maybeNode = nodes.find(node => node.name === asset.type);
      if (maybeNode) {
        maybeNode.children.push({ name: asset.ticker, filterKey, id: asset.id, parentId: maybeNode.id });
      }
    });
    return nodes.filter(node => node.children.length);
  }
}
